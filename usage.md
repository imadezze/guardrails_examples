Below is a table that summarizes the differences and common points between the various LangChain integration methods with NeMo Guardrails, along with examples of when you might choose one method over another.

| **Method**                           | **Description**                                                                                                                                                                            | **Key Differences**                                                                                                                      | **When to Use**                                                                                                                                                             |
|----------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Add Guardrails to a Chain**          | Directly wraps an existing LangChain chain so that every call is processed through the guardrails layer.                                                                                    | Applies safety checks continuously with minimal modifications using a simple wrapping (pipe operator).                                   | Use when you have an existing chain and you want a straightforward, one-shot application of safety rules to all interactions without conditional logic.                 |
| **Using a Chain inside Guardrails**    | Registers a LangChain chain as an action within a broader guardrails dialogue flow so that it’s invoked conditionally.                                                                         | The chain is integrated as an action rather than being always active; it becomes one step in a larger, controlled conversation flow.       | Use when you need the chain to be executed only under certain conditions (for example, based on user input) as part of a more complex dialogue flow.                        |
| **LangSmith Integration**              | Integrates LangSmith to provide detailed tracing, monitoring, and debugging for chains that are wrapped with guardrails.                                                                      | Focuses on observability rather than altering how inputs and outputs are handled; it adds monitoring and trace logging to the existing chain. | Use during development or troubleshooting when you need to gain insights into how data is transformed and to understand the effects of guardrails on your chain’s behavior. |
| **RunnableRails**                      | The core interface used to wrap LangChain components with Guardrails, offering extra features like key mapping, prompt passthrough, and limited streaming support.                       | Offers advanced control over input/output formatting and additional functionality beyond basic wrapping.                                  | Use when your application requires fine-tuned control over how messages are handled (e.g., managing multiple keys or when streaming is desired with known limitations).    |
| **Chain-With-Guardrails**              | Implements a comprehensive, end-to-end conversation chain by integrating all components (retriever, prompt, LLM) within a guarded flow.                                                       | Integrates multiple parts of a conversation into one guarded pipeline, ensuring that every stage adheres to your safety policies.         | Use when building full conversation systems—such as a Retrieval-Augmented Generation (RAG) system—where all elements need to be controlled for consistent safety.       |
| **Runnable-As-Action**                 | Registers a LangChain chain as an action to be invoked as part of a larger guardrails dialogue flow.                                                                                         | Allows selective, conditional invocation rather than wrapping the entire chain; fits as one of several steps within a controlled flow.    | Use when you want to conditionally execute a chain (or external tool) as one action among many, enabling flexible branching and conditional dialogues.                    |

Each method leverages the same underlying safety and control principles via NeMo Guardrails, but they provide different levels of integration and control depending on your application’s needs.